Expected = directive* nl* state nl* EOL
directive = "#" d:word space* v:word_alnumsp nl+ {return {"directive":{"d": d, "val":v}}; }
state = (valState looping)*
looping = (loopStart loopEnd)*
loopStart = (ls:beg child:valState+ {return {"beginCount":ls.length,"children":child.length,"child":child}})
loopEnd = (le:end* {return {"endCount":le.length};} )
valState = stateName (valStateVal/valStateDec)* nl+
valStateDec = space+ decState_val:word_alnumsp {return {"decVal":decState_val}}
stateName = space* state_name1:word_alnumsp {return {"name":state_name1};}
valStateVal = space+ valState_val:(word_alnumsp comma?)* {return {"count":valState_val.length,"value":valState_val};}
word = wo:letter+ {return wo.join("")}
word_alnum = al:alnum+ {return al.join("")}
word_alnumsp = alsp:alnumsp+ {return alsp.join("")}
letter = [a-zA-Z]
alnum = [a-zA-Z0-9]
alnumsp = [a-zA-Z0-9"'&._()\\|:]
space = " "
nl = '\n' {return "NL"}
EOL = nl / !. {return "EOF"}
beg = space* begin:((b e g i n)/[{]) space* nl+ {return "begin"}
end = space* end:((e n d)/[}]) space* nl+ {return "end"}
comma = space* [,] space* {return ","}
b = ["B"]
e = ["E"]
g = ["G"]
i = ["I"]
n = ["N"]
d = ["D"]